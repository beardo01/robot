#pragma config(Sensor, S1,     touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     lightSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          mL,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mR,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* 
Turns the robot by activating a servo motor and stopping the opposite motor

m = which motor we use to turn the robot
    0 = right motor
    1 = left motor
rotations = how many 90 degree turns to do
speed = the speed to set the chosen servo motor to.
*/
void turn(int m, int rotations, int speed) {
	motor[mL] = 0;
	motor[mR] = 0;
	if (m) {
		moveMotorTarget(mL, rotations * 350, speed);
		waitUntilMotorStop(mL);
	} else {
		moveMotorTarget(mR, rotations * 350, speed);
		waitUntilMotorStop(mR);
	}
}
/*
Sets the speed of both motors

speed = rate the motors work at (0 to 100)
*/
void setSpeed(int speed) {
  motor[mL] = speed;
  motor[mR] = speed;
}
/*
Used to find the closest structure and face the robot towards it
*/
void findTower() {
  float min = 999;
  // set current to the value of the Motor Encoder
  int current = getMotorEncoder(mL);
  // do a 360 degree turn	
  while (getMotorEncoder(mL) <= current + (350 * 4)) {
      motor[mL] = 30;
      // while turning, find the closest structure and record the distance to it 
      if (getUSDistance(sonar) < min) {
        min = getUSDistance(sonar);
      }
   }
   // spin the robot to where the sonar recored the closest object	
   while (getUSDistance(sonar) > (min + 1)) {
       motor[mL] = 30;
   }
   // we are now facing the closest opbject so stop both motors 	
   setSpeed(0);
}

void pushTower() {
	while(true) { //add a flag
		motor[mL] = 10;
		motor[mR] = 10;

		if (getUSDistance(sonar) < 7 && getColorReflected(lightSensor) < 14) {
			while(getColorReflected(lightSensor) < 14){ //add a flag
			motor[mL] = 0;
			motor[mR] = 0;
			// set a flag to break the loop
		}
		}
	}
}

task main() {
        moveMotorTarget(mL, 4500, 100);
        moveMotorTarget(mR, 4500, 100);
        waitUntilMotorStop(mL);
        waitUntilMotorStop(mR);
        findTower();
        pushTower();
}
/*
task main() {
	wait1Msec(500);
	int count = 0;
	int white = 0; //flag to check we have moved off black
	bool phase1 = true;

	while(phase1) {
			if (count == 0) {
				// start on black and move in the direction its facing till we reach a black tile
				setSpeed(10);
			}

			if (getColorReflected(lightSensor) <= 14 && white == 1 && count == 0) {
				wait1Msec(500);
				playSound(soundBeepBeep);
  			turn(1, 1, 20); // 90 degree left turn
				count++;
				white = 0;
				setSpeed(40); // we are on first black tile
			}

			// light tiles
			if (getColorReflected(lightSensor) >= 20) {
				white = 1;
			}

			// black squares
			if (getColorReflected(lightSensor) <= 14 && count <= 15 && white == 1) {
				playSound(soundBlip);
				count++;
				white = 0;
			}

			if (count == 15) {
        turn(1, 1, 20);
        moveMotorTarget(mL, 4500, 40);
        moveMotorTarget(mR, 4500, 40);
        waitUntilMotorStop(mL);
        waitUntilMotorStop(mR);
        phase1 = false;
        findTower();
		}
	}
		//setSpeed(0);
    //playSound(soundException);
}*/
