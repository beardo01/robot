#pragma config(Sensor, S1,     touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     lightSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          mL,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mR,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
A list of constants for the program to use. This can be configured on the day of
the assignment.
*/

// Colors
#define BLACK_UPPER 14
#define WHITE_LOWER 52
#define GREY_LOWER 30
#define GREY_UPPER 52

// Turning
#define SPIN 690
#define QUARTER_TURN 350
#define WHEEL_ROTATION 200

/*
Checks if the sensor currently senses black or not.

@return true if the light reflected is less than or equal to 14, otherwise false.
*/
bool isBlack() {
	return (getColorReflected(lightSensor) <= BLACK_UPPER);
}

/*
Checks if the sensor currently senses white or not.

@return true if the light reflected is greater than or equal to 52, otherwise false.
*/
bool isWhite() {
	return (getColorReflected(lightSensor) >= WHITE_LOWER);
}

/*
Checks if the sensor currently senses grey or not.

@return true if the light reflected is between 30 and 52, otherwise false.
*/
bool isGrey() {
	return (getColorReflected(lightSensor) > GREY_LOWER && getColorReflected(lightSensor) < GREY_UPPER);
}

/*
Sets the speed of both motors.

@param speed = rate the motors work at (0 to 100)
*/
void setSpeed(int speed) {
	motor[mL] = speed;
	motor[mR] = speed;
}

/*
Turns the robot by activating a servo motor and stopping the opposite motor

@param m = which motor we use to turn the robot
    0 = right motor
    1 = left motor
@param rotations = how many 90 degree turns to do
@param speed = the speed to set the chosen servo motor to.
*/
void turn(int m, int rotations, int speed) {
	setSpeed(0);
	if (m) {
		moveMotorTarget(mL, rotations * QUARTER_TURN, speed);
		waitUntilMotorStop(mL);
	} else {
		moveMotorTarget(mR, rotations * QUARTER_TURN, speed);
		waitUntilMotorStop(mR);
	}
}

/*
Drives the robot forward a set number of full wheel rotations.

@param num The number of wheel rotations to drive.
@param speed The speed to drive at.
*/
void drive(int num, int speed) {
	int current = getMotorEncoder(mL);
	while(getMotorEncoder(mL) <= current + (WHEEL_ROTATION * num)) {
		setSpeed(speed);
	}
	setSpeed(0);
}

/*
Finds the closest object through it, using sonar and faces towards it.
*/
void findTower() {
	float min = 255;

	// Set current to the value of the Motor Encoder
	int current = getMotorEncoder(mL);
	// Do a 360 degree turn
	while (getMotorEncoder(mL) <= current + SPIN) {
		motor[mL] = 20;
		motor[mR] = -20;
		// While turning, find the closest structure and record the distance to it
		if (getUSDistance(sonar) < min) {
			min = getUSDistance(sonar);
		}
	}

	// Check to see if we found the tower at all, or if we need to drive and retry.
	if (min > 100) {
		drive(5, 30);
		findTower();
		return;
	}

	// Spin the robot to where the sonar recored the closest object
	current = getMotorEncoder(mL);
	while ((getUSDistance(sonar) > (min + 1)) && getMotorEncoder(mL) <= current + SPIN) {
		motor[mL] = 20;
		motor[mR] = -20;
	}

	// We are now facing the closest object so stop both motors
	setSpeed(0);
}

/*
void approachTower() {

}*/

/*void spin(int num) {
	int current = getMotorEncoder(mL);
	while (getMotorEncoder(mL) <= current + (700 * num)) {
		motor[mL] = 20;
		motor[mR] = -20;
	}
}*/

/*
Drives the remaining distance to the tower, pushes it off the black and then
drives a set distance.
*/
void pushTower() {
	bool pushedOff = false;
	while(pushedOff == false) {
		// Drive towards the tower
		setSpeed(30);

		// Detect that we are close and speed up for a certain amount of time
		if ((getUSDistance(sonar) < 7) && isBlack()) {
			while((isBlack()) && (pushedOff == false)) {
				drive(2, 40);
				pushedOff = true;
			}
		}
	}
	playSound(soundUpwardTones);
	setSpeed(0);
}

task main() {
	
}

/*task main() {

        moveMotorTarget(mL, 4500, 100);
        moveMotorTarget(mR, 4500, 100);
        waitUntilMotorStop(mL);
        waitUntilMotorStop(mR);
        findTower();
        //pushTower();


}*/
/*
task main() {
	// colour ranges
	// black tile: <= to 14

	wait1Msec(500);
	int count = 0;
	int white = 0; //flag to check we have moved off black
	bool phase1 = true;

	while(phase1) {
			if (count == 0) {
				// start on black and move in the direction its facing till we reach a black tile
				setSpeed(10);
			}

			if (getColorReflected(lightSensor) <= 14 && white == 1 && count == 0) {
				wait1Msec(500);
				playSound(soundBeepBeep);
  			turn(1, 1, 20); // 90 degree left turn
				count++;
				white = 0;
				setSpeed(40); // we are on first black tile
			}

			// light tiles
			if (getColorReflected(lightSensor) >= 20) {
				white = 1;
			}

			// black squares
			if (getColorReflected(lightSensor) <= 14 && count <= 15 && white == 1) {
				playSound(soundBlip);
				count++;
				white = 0;
			}

			if (count == 15) {
        turn(1, 1, 20);
        moveMotorTarget(mL, 4500, 40);
        moveMotorTarget(mR, 4500, 40);
        waitUntilMotorStop(mL);
        waitUntilMotorStop(mR);
        phase1 = false;
        findTower();
		}
	}
		//setSpeed(0);
    //playSound(soundException);
}*/
