#pragma config(Sensor, S1,     touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     lightSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          mL,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mR,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


bool isBlack() {
	return (getColorReflected(lightSensor) <= 14);
}

bool isWhite() {
	return (getColorReflected(lightSensor) >= 52);
}

// Will stop on grout and on grey tiles. Can use for edge detection
bool isGrey() {
	return (getColorReflected(lightSensor) > 30 && getColorReflected(lightSensor) < 52);
}

/*
Turns the robot by activating a servo motor and stopping the opposite motor

@param m = which motor we use to turn the robot
    0 = right motor
    1 = left motor
@param rotations = how many 90 degree turns to do
@param speed = the speed to set the chosen servo motor to.
*/
void turn(int m, int rotations, int speed) {
	motor[mL] = 0;
	motor[mR] = 0;
	if (m) {
		moveMotorTarget(mL, rotations * 350, speed);
		waitUntilMotorStop(mL);
	} else {
		moveMotorTarget(mR, rotations * 350, speed);
		waitUntilMotorStop(mR);
	}
}
/*
Sets the speed of both motors

@param speed = rate the motors work at (0 to 100)
*/
void setSpeed(int speed) {
  motor[mL] = speed;
  motor[mR] = speed;
}
/*
Used to find the closest structure and face the robot towards it
*/
void findTower() {
  float min = 999;
  // set current to the value of the Motor Encoder
  int current = getMotorEncoder(mL);
  // do a 360 degree turn
  while (getMotorEncoder(mL) <= current + (300 * 2)) {
      motor[mL] = 20;
      motor[mR] = -20;
      // while turning, find the closest structure and record the distance to it
      if (getUSDistance(sonar) < min) {
        min = getUSDistance(sonar);
      }
   }
   // spin the robot to where the sonar recored the closest object
   int prespin = getMotorEncoder(mL);
   while ((getUSDistance(sonar) > (min + 1)) || getMotorEncoder(mL) <= prespin + (300 * 2)) {
       motor[mL] = 20;
       motor[mR] = -20;
   }
   // we are now facing the closest object so stop both motors
   setSpeed(0);
}

void pushTower() {
	bool pushedOff = false;
	int currentBefore = getMotorEncoder(mL);
	while(pushedOff == false) {
		setSpeed(30);

		// If we drive for too long, refind tower
		if (getMotorEncoder(mL) > (currentBefore + (3 * 350))) {
			currentBefore = getMotorEncoder(mL);
			//setSpeed(0);
			findTower();
		}

		if ((getUSDistance(sonar) < 7) && isBlack()) {
			while((isBlack()) && (pushedOff == false)) {
				int current = getMotorEncoder(mL);
				while (getMotorEncoder(mL) < current + 340) {
					setSpeed(40);
		  	}
		  pushedOff = true;
		}
	}
}
	playSound(soundUpwardTones);
	setSpeed(0);

}


task main() {

        moveMotorTarget(mL, 4500, 100);
        moveMotorTarget(mR, 4500, 100);
        waitUntilMotorStop(mL);
        waitUntilMotorStop(mR);
        findTower();
        pushTower();
}
/*
task main() {
	// colour ranges
	// black tile: <= to 14

	wait1Msec(500);
	int count = 0;
	int white = 0; //flag to check we have moved off black
	bool phase1 = true;

	while(phase1) {
			if (count == 0) {
				// start on black and move in the direction its facing till we reach a black tile
				setSpeed(10);
			}

			if (getColorReflected(lightSensor) <= 14 && white == 1 && count == 0) {
				wait1Msec(500);
				playSound(soundBeepBeep);
  			turn(1, 1, 20); // 90 degree left turn
				count++;
				white = 0;
				setSpeed(40); // we are on first black tile
			}

			// light tiles
			if (getColorReflected(lightSensor) >= 20) {
				white = 1;
			}

			// black squares
			if (getColorReflected(lightSensor) <= 14 && count <= 15 && white == 1) {
				playSound(soundBlip);
				count++;
				white = 0;
			}

			if (count == 15) {
        turn(1, 1, 20);
        moveMotorTarget(mL, 4500, 40);
        moveMotorTarget(mR, 4500, 40);
        waitUntilMotorStop(mL);
        waitUntilMotorStop(mR);
        phase1 = false;
        findTower();
		}
	}
		//setSpeed(0);
    //playSound(soundException);
}*/
